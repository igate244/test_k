<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>ã„ã‚ã¯ãƒ»ã‚†ã†ã‚Šãƒ»ãªãã•ãƒ»ã¤ã‚ˆã—ãƒ»ã‚Šã• â€” ã™ã„ã‹ã‚²ãƒ¼ãƒ é¢¨</title>
  <style>
    :root {
      --bg: #0b132b;
      --panel: #1c2541;
      --accent: #5bc0be;
      --text: #f2f7ff;
      --warn: #ff8c8c;
    }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", "Meiryo", sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: none; /* for better mobile control */
    }
    .wrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      place-items: center;
      gap: 8px;
      padding: 8px;
      height: 100%;
      box-sizing: border-box;
    }
    .topbar {
      width: min(440px, 92vw);
      background: linear-gradient(180deg, #222b4d, var(--panel));
      border: 1px solid #2e3a63;
      border-radius: 14px;
      padding: 8px 12px;
      display: grid;
      grid-template-columns: 1fr auto auto auto;
      align-items: center;
      gap: 10px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
    }
    .brand {
      font-weight: 700;
      letter-spacing: .03em;
    }
    .score {
      font-variant-numeric: tabular-nums;
      padding: 4px 8px;
      border-radius: 8px;
      background: #121a34;
      border: 1px solid #2a3560;
    }
    .nextbox {
      display: grid;
      grid-template-columns: auto auto;
      gap: 8px;
      align-items: center;
    }
    .nextbox small { opacity: .8; }
    #nextCanvas {
      width: 40px; height: 40px;
      background: #0f1630;
      border: 1px solid #2a3560; border-radius: 8px;
    }
    button, .btn {
      appearance: none; color: var(--text);
      background: var(--accent);
      border: none; border-radius: 10px;
      padding: 8px 12px; font-weight: 700; cursor: pointer;
      box-shadow: 0 6px 18px rgba(91,192,190,.35);
    }
    button:active { transform: translateY(1px); }

    #stageWrap { position: relative; }
    #stage {
      display: block;
      width: min(440px, 92vw);
      height: calc(min(440px, 92vw) * 1.5);
      max-height: 88vh;
      background: radial-gradient(1200px 400px at 50% -200px, #20305e, #0b132b 60%);
      border: 1px solid #2a3560;
      border-radius: 16px;
      box-shadow: inset 0 4px 24px rgba(0,0,0,.35), 0 12px 28px rgba(0,0,0,.35);
    }
    .hud {
      position: absolute; inset: 0; pointer-events: none;
      border-radius: 16px;
    }
    .line {
      position: absolute; left: 8px; right: 8px; height: 0;
      border-top: 2px dashed rgba(255,255,255,.25);
    }
    .line.top { top: 64px; }
    .line.lose { top: 104px; border-top-color: var(--warn); }
    .ghost {
      position: absolute; width: 0; height: 0; left: 0; top: 0; pointer-events: none;
    }
    .goPanel {
      position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;
      background: linear-gradient(180deg, rgba(11,19,43,0), rgba(11,19,43,.55));
      opacity: 0; transition: opacity .25s ease;
    }
    .goPanel.show { opacity: 1; }
    .goCard {
      pointer-events: auto;
      padding: 16px 18px; border-radius: 16px; text-align: center; width: min(360px, 90%);
      backdrop-filter: blur(8px);
      background: rgba(18,26,52,.92);
      border: 1px solid #2a3560;
      box-shadow: 0 14px 40px rgba(0,0,0,.5);
    }
    .footer { opacity: .7; font-size: 12px; }
    a { color: #8fd6d4; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">ğŸ‰ ã™ã„ã‹ã‚²ãƒ¼ãƒ é¢¨ï¼ˆã„ã‚ã¯â†’ã‚†ã†ã‚Šâ†’ãªãã•â†’ã¤ã‚ˆã—â†’ã‚Šã•ï¼‰</div>
      <div class="nextbox"><small>NEXT</small><canvas id="nextCanvas" width="40" height="40"></canvas></div>
      <div class="score">SCORE <span id="score">0</span></div>
      <button id="restartBtn" title="R ã‚­ãƒ¼ã§ã‚‚å†é–‹">ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    </div>

    <div id="stageWrap">
      <!-- Matter.js ãŒæç”»ã™ã‚‹ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
      <canvas id="stage"></canvas>
      <div class="hud">
        <div class="line top" title="ã“ã“ã‚ˆã‚Šä¸Šã§ç©ã‚€ã¨å±é™ºã‚¾ãƒ¼ãƒ³"></div>
        <div class="line lose" title="ã“ã“ã‚’è¶…ãˆã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼"></div>
      </div>
      <div class="goPanel" id="goPanel">
        <div class="goCard">
          <h2 style="margin:6px 0 10px">Game Overâ€¦</h2>
          <p style="margin:0 0 12px">ã‚Šã•Ã—2ã§æ¶ˆãˆã‚‹ã‚ˆã€‚ç”»é¢ã‚¿ãƒƒãƒ— / ã‚¹ãƒšãƒ¼ã‚¹ã§è½ä¸‹ã€å·¦å³ã«æŒ‡/ãƒã‚¦ã‚¹ã§ä½ç½®èª¿æ•´ã€‚</p>
          <p style="margin:0 0 14px">ã‚¹ã‚³ã‚¢ï¼š<b id="finalScore">0</b></p>
          <button id="againBtn">ã‚‚ã†ä¸€åº¦ã‚ãã¶</button>
        </div>
      </div>
    </div>

    <div class="footer">
      <p style="margin:0">
        å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã§å‹•ä½œï¼GitHub Pages ç›´ç½®ãOKã€‚ç”»åƒã«å·®ã—æ›¿ãˆã‚‹å ´åˆã¯ <code>assets/iroha.png, yuri.png, nagisa.png, tsuyoshi.png, risa.png</code> ã‚’ç½®ãã€<code>USE_IMAGES = true</code> ã«ã—ã¦ãã ã•ã„ã€‚
      </p>
    </div>
  </div>

  <!-- Matter.js CDN -->
  <script src="https://unpkg.com/matter-js@0.20.0/build/matter.min.js" defer>/**/})();
  </script>
  <script>
    window.addEventListener('load', () => {
      const USE_IMAGES = true; // ç”»åƒã‚’ä½¿ã†å ´åˆã¯ true ã«ã€‚assets/*.png ã‚’é…ç½®ã—ã¦ãã ã•ã„ã€‚

      // ç”»åƒãƒ­ãƒ¼ãƒ‰ï¼ˆä»»æ„ï¼‰
      const imageFiles = {
        0: 'assets/iroha.png',
        1: 'assets/yuri.png',
        2: 'assets/nagisa.png',
        3: 'assets/tsuyoshi.png',
        4: 'assets/risa.png'
      };
      const images = {};
      if (USE_IMAGES) {
        Object.keys(imageFiles).forEach(k => {
          const img = new Image();
          img.src = imageFiles[k];
          images[k] = img;
        });
      }

      // ====== åŸºæœ¬è¨­å®š ======
      const NAMES = ['ã„ã‚ã¯','ã‚†ã†ã‚Š','ãªãã•','ã¤ã‚ˆã—','ã‚Šã•'];
      const TIERS = [
        { name: NAMES[0], r: 16, color: '#ffadad', score: 1 },
        { name: NAMES[1], r: 22, color: '#ffd6a5', score: 3 },
        { name: NAMES[2], r: 30, color: '#fdffb6', score: 6 },
        { name: NAMES[3], r: 40, color: '#caffbf', score: 12 },
        { name: NAMES[4], r: 54, color: '#a0c4ff', score: 25 }, // ã‚Šã•
      ];
      const BONUS_CLEAR = 100; // ã‚Šã•Ã—2ã§æ¶ˆãˆãŸã¨ã

      const stage = document.getElementById('stage');
      const nextCanvas = document.getElementById('nextCanvas');
      const nextCtx = nextCanvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const restartBtn = document.getElementById('restartBtn');
      const goPanel = document.getElementById('goPanel');
      const againBtn = document.getElementById('againBtn');
      const finalScoreEl = document.getElementById('finalScore');

      // å›ºå®šã‚µã‚¤ã‚ºï¼ˆã‚²ãƒ¼ãƒ ãƒãƒ©ãƒ³ã‚¹èª¿æ•´æ¸ˆï¼‰
      const WIDTH = Math.min(440, Math.floor(window.innerWidth * 0.92));
      const HEIGHT = Math.min(720, Math.floor(WIDTH * 1.5));
      stage.width = WIDTH; stage.height = HEIGHT;

      // ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
      const SPAWN_Y = 160; // å‡ºç¾ãƒ©ã‚¤ãƒ³ï¼ˆè² ã‘ãƒ©ã‚¤ãƒ³ã‚ˆã‚Šååˆ†ä¸‹ã«ï¼‰
      const LOSE_Y = 104; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ³ï¼ˆã“ã®é«˜ã•ã‚ˆã‚Šä¸Šã«ç©ã¾ã‚Œã‚‹ã¨OUTï¼‰

      // Matter.js ã‚·ãƒ§ãƒ¼ãƒˆãƒãƒ³ãƒ‰
      const { Engine, Render, Runner, World, Bodies, Body, Events, Composite } = Matter;

      const engine = Engine.create();
      engine.gravity.y = 1.05; // ã»ã‚“ã®å°‘ã—è»½ã‚
      const render = Render.create({
        canvas: stage,
        engine,
        options: {
          width: WIDTH,
          height: HEIGHT,
          wireframes: false,
          background: 'transparent'
        }
      });
      Render.run(render);
      const runner = Runner.create();
      Runner.run(runner, engine);

      // å¢ƒç•Œï¼ˆå£ã¨åºŠï¼‰
      const wallT = 40;
      const walls = [
        Bodies.rectangle(WIDTH/2, HEIGHT + wallT/2 - 8, WIDTH-16, wallT, { isStatic: true, render:{ fillStyle: '#132048' } }), // floor (å°‘ã—é«˜æ‘©æ“¦)
        Bodies.rectangle(-wallT/2 + 8, HEIGHT/2, wallT, HEIGHT-16, { isStatic: true, render:{ fillStyle: '#162350' } }), // left
        Bodies.rectangle(WIDTH + wallT/2 - 8, HEIGHT/2, wallT, HEIGHT-16, { isStatic: true, render:{ fillStyle: '#162350' } }), // right
        Bodies.rectangle(WIDTH/2, -wallT/2, WIDTH, wallT, { isStatic: true, render:{ fillStyle: 'transparent' } }), // ceiling guard
      ];
      World.add(engine.world, walls);

      // ã‚¹ãƒ†ãƒ¼ãƒˆ
      let currentX = WIDTH/2;
      let currentTier = rollTier();
      let nextTier = rollTier();
      let score = 0;
      let gameOver = false;
      let dropCooldown = false; // é€£æ‰“é˜²æ­¢

      drawNextPreview(nextTier);

      // å…¥åŠ›
      const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
      function setXFromClient(clientX) {
        const rect = stage.getBoundingClientRect();
        const x = ((clientX - rect.left) / rect.width) * WIDTH;
        currentX = clamp(x, 24, WIDTH-24);
      }
      stage.addEventListener('pointermove', (e) => setXFromClient(e.clientX));
      stage.addEventListener('pointerdown', (e) => {
        setXFromClient(e.clientX);
        tryDrop();
      });
      window.addEventListener('keydown', (e) => {
        if (e.code === 'ArrowLeft') { currentX = clamp(currentX - 18, 24, WIDTH-24); }
        if (e.code === 'ArrowRight'){ currentX = clamp(currentX + 18, 24, WIDTH-24); }
        if (e.code === 'Space' || e.code === 'Enter') { tryDrop(); }
        if (e.key === 'r' || e.key === 'R') restart();
      }, { passive: false });
      restartBtn.addEventListener('click', restart);
      againBtn.addEventListener('click', restart);

      function tryDrop(){
        if (gameOver || dropCooldown) return;
        dropCooldown = true; setTimeout(() => dropCooldown = false, 120);
        dropPiece(currentTier, currentX, SPAWN_Y);
        currentTier = nextTier;
        nextTier = rollTier();
        drawNextPreview(nextTier);
      }

      // ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆï¼ˆåºç›¤ã¯å°ã•ã‚ãŒå‡ºã‚„ã™ã„ï¼‰
      function rollTier(){
        const bag = [0,0,0,1,1,2];
        return bag[Math.floor(Math.random()*bag.length)];
      }

      // ãƒ”ãƒ¼ã‚¹ç”Ÿæˆ
      function createPiece(tier, x, y){
        const t = TIERS[tier];
        const body = Bodies.circle(x, y, t.r, {
          restitution: 0.05,
          friction: 0.12,
          frictionAir: 0.0025,
          density: 0.0018 * (1 + tier*0.22),
          render: { fillStyle: t.color, strokeStyle: '#2a2a2a', lineWidth: 1 }
        });
        body.plugin = { tier, removed: false, bornAt: performance.now() };
        return body;
      }
      function dropPiece(tier, x, y){
        const body = createPiece(tier, x, y);
        World.add(engine.world, body);
      }

      // ã‚¹ã‚³ã‚¢
      function addScore(v){
        score += v; scoreEl.textContent = score;
      }

      // ãƒãƒ¼ã‚¸åˆ¶å¾¡
      const mergeKeys = new Set();
      Events.on(engine, 'collisionStart', (e) => {
        for (const p of e.pairs){
          const a = p.bodyA, b = p.bodyB;
          if (!a.plugin || !b.plugin) continue;
          if (a.plugin.removed || b.plugin.removed) continue;
          if (a.plugin.tier === undefined || b.plugin.tier === undefined) continue;
          if (a.plugin.tier !== b.plugin.tier) continue;
          // å£ãªã©é™çš„ã¨ã¯åˆä½“ã•ã›ãªã„
          if (a.isStatic || b.isStatic) continue;
          // ç”Ÿç›´å¾Œã¯èª¤çˆ†é˜²æ­¢
          const now = performance.now();
          if (now - a.plugin.bornAt < 80 || now - b.plugin.bornAt < 80) continue;

          const key = [a.id, b.id].sort().join('-');
          if (mergeKeys.has(key)) continue;
          mergeKeys.add(key);
          queueMerge(a, b);
        }
      });

      function queueMerge(a, b){
        // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã§å®Ÿè¡Œï¼ˆå®‰å®šåŒ–ï¼‰
        setTimeout(() => doMerge(a, b), 0);
      }
      function doMerge(a, b){
        try {
          if (!Composite.get(engine.world, a.id, 'body') || !Composite.get(engine.world, b.id, 'body')) return;
          if (a.plugin.removed || b.plugin.removed) return;
          const tier = a.plugin.tier;
          const nx = (a.position.x + b.position.x)/2;
          const ny = (a.position.y + b.position.y)/2;

          // æ¶ˆå»
          a.plugin.removed = b.plugin.removed = true;
          World.remove(engine.world, a);
          World.remove(engine.world, b);

          if (tier < TIERS.length - 1) {
            // æ¬¡ãƒ©ãƒ³ã‚¯ã«æ˜‡æ ¼
            const next = createPiece(tier + 1, nx, ny);
            World.add(engine.world, next);
            addScore(TIERS[tier + 1].score);
          } else {
            // ã‚Šã•åŒå£«ã¯æ¶ˆæ»… â†’ ãƒœãƒ¼ãƒŠã‚¹
            addScore(BONUS_CLEAR);
            // ã¡ã‚‡ã£ã¨ã ã‘æ‰“ã¡ä¸Šã’èŠ±ç«çš„ãªæ¼”å‡ºï¼ˆç°¡æ˜“ï¼‰
            burst(nx, ny, 10);
          }
          // æ—©ã‚ã«ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
          checkGameOver();
        } finally {
          // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          mergeKeys.clear();
        }
      }

      function burst(x, y, n){
        for (let i=0;i<n;i++){
          const r = 2 + Math.random()*3;
          const p = Bodies.circle(x, y, r, {
            restitution: 0.6,
            friction: 0.02,
            density: 0.0008,
            render: { fillStyle: ['#fff','#8fd6d4','#ffd6a5','#caffbf'][i%4] }
          });
          Body.setVelocity(p, { x: (Math.random()-0.5)*6, y: -Math.random()*6 - 2 });
          World.add(engine.world, p);
          // è‡ªå‹•æ¶ˆæ»…
          setTimeout(() => { try { World.remove(engine.world, p); } catch{} }, 1500 + Math.random()*500);
        }
      }

      // æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ï¼šã‚¬ã‚¤ãƒ‰ã‚„ãƒ†ã‚­ã‚¹ãƒˆæç”»ã€æ•—åŒ—ãƒã‚§ãƒƒã‚¯
      Events.on(render, 'afterRender', () => {
        const ctx = render.context;

        // ãƒ”ãƒ¼ã‚¹ã®ãƒ©ãƒ™ãƒ« or ç”»åƒ
        const bodies = Composite.allBodies(engine.world);
        for (const body of bodies){
          if (!body.plugin || body.plugin.tier === undefined) continue;
          const t = TIERS[body.plugin.tier];
          const { x, y } = body.position;
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(body.angle);

          if (USE_IMAGES && images[body.plugin.tier] && images[body.plugin.tier].complete) {
            // å††å½¢ã«ã‚¯ãƒªãƒƒãƒ—ã—ã¦ç”»åƒã‚’æã
            ctx.beginPath();
            ctx.arc(0, 0, t.r, 0, Math.PI*2);
            ctx.closePath();
            ctx.clip();
            const img = images[body.plugin.tier];
            const s = t.r * 2;
            ctx.drawImage(img, -s/2, -s/2, s, s);
          } else {
            // ãƒ†ã‚­ã‚¹ãƒˆãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#1a1a1a';
            ctx.font = `bold ${Math.max(12, Math.floor(t.r*0.9))}px system-ui, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(t.name, 0, 1);
          }
          ctx.restore();
        }

        // ã‚´ãƒ¼ã‚¹ãƒˆï¼ˆç¾åœ¨ä½ç½®ï¼‰
        if (!gameOver) {
          const t = TIERS[currentTier];
          ctx.save();
          ctx.setLineDash([6, 6]);
          ctx.strokeStyle = 'rgba(255,255,255,.6)';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(currentX, SPAWN_Y, t.r, 0, Math.PI*2); ctx.stroke();
          ctx.restore();
        }
      });

      // æ•—åŒ—ãƒã‚§ãƒƒã‚¯ï¼ˆä¸€å®šé–“éš”ã§è»½ãï¼‰
      let frame = 0;
      Events.on(engine, 'afterUpdate', () => {
        frame++;
        if (frame % 6 !== 0) return;
        checkGameOver();
      });

      function checkGameOver(){
        if (gameOver) return;
        const now = performance.now();
        const bodies = Composite.allBodies(engine.world);
        let minTop = Infinity;
        for (const body of bodies){
          if (!body.plugin || body.plugin.tier === undefined) continue;
          // ç›´å¾Œã®ãƒ”ãƒ¼ã‚¹ã‚„è½ä¸‹ä¸­ã¯é™¤å¤–ï¼ˆèª¤åˆ¤å®šé˜²æ­¢ï¼‰
          const age = now - (body.plugin.bornAt || 0);
          const settled = body.speed < 0.12; // ã»ã¼é™æ­¢
          if (age < 900 || !settled) continue;
          const r = TIERS[body.plugin.tier].r;
          const top = body.position.y - r;
          if (top < minTop) minTop = top;
        }
        if (minTop < LOSE_Y){
          gameOver = true;
          finalScoreEl.textContent = score;
          goPanel.classList.add('show');
        }
      }
        if (minTop < LOSE_Y){
          gameOver = true;
          finalScoreEl.textContent = score;
          goPanel.classList.add('show');
        }
      }

      function restart(){
        // ãƒ¯ãƒ¼ãƒ«ãƒ‰åˆæœŸåŒ–
        const all = Composite.allBodies(engine.world);
        for (const b of all){
          if (!walls.includes(b)) try { World.remove(engine.world, b); } catch{}
        }
        score = 0; scoreEl.textContent = '0';
        currentTier = rollTier();
        nextTier = rollTier();
        drawNextPreview(nextTier);
        gameOver = false;
        goPanel.classList.remove('show');
      }

      function drawNextPreview(tier){
        const t = TIERS[tier];
        nextCtx.clearRect(0,0,40,40);
        nextCtx.save();
        nextCtx.translate(20,20);
        nextCtx.beginPath();
        nextCtx.arc(0,0,14,0,Math.PI*2);
        nextCtx.fillStyle = t.color; nextCtx.fill();
        nextCtx.strokeStyle = '#2a2a2a'; nextCtx.lineWidth = 1; nextCtx.stroke();
        nextCtx.fillStyle = '#1a1a1a';
        nextCtx.font = 'bold 10px system-ui, sans-serif';
        nextCtx.textAlign = 'center'; nextCtx.textBaseline = 'middle';
        nextCtx.fillText(t.name, 0, 0);
        nextCtx.restore();
      }

      // åˆæœŸãƒ’ãƒ³ãƒˆï¼šä¸­å¿ƒã«ã‚«ãƒ¼ã‚½ãƒ«
      currentX = WIDTH/2;
    });
  </script>
</body>
</html>
